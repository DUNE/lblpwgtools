#!/usr/bin/env python

# Run me on the DB file output from the TimeTracker module
# https://cdcvs.fnal.gov/redmine/projects/art/wiki/TimeTracker

import sqlite3
import code
import argparse
import json
import sys


#///////////////////////////////////////////////////////////////////////////////
#  Parse command-line arguments and hand bundle them up in a nice, simple object

# TODO: Could have options to only select a subset of modules etc. Maybe we
# could have other plotting options like whisker plots and scatter plots.
argParser = argparse.ArgumentParser(description='Process arguments')


# No need to implement anything for this, ROOT sees it and reacts appropriately
argParser.add_argument('-b', '--batch', action='store_true',
                       default=False,
                       help="Batch mode (don't open any windows)")

argParser.add_argument('-q', '--quit', action='store_true', dest='QUIT',
                       default=False,
                       help='Quit immediately when done')

argParser.add_argument('-o', '--output', action='store', dest='OUTPUT',
                       metavar='out.png',
                       type=str,
                       help='Path to output image file')

jsonGroup = argParser.add_mutually_exclusive_group(required=False)
jsonGroup.add_argument('-j', '--json', action='store_true', dest='EXPORT_JSON',
                       default=False,
                       help='Export a summary in JSON format')

jsonGroup.add_argument('-J', '--JSON', action='store', dest='EXPORT_JSON_NAME',
                       metavar='out.json',
		       type=str,
		       help='Export a summary in JSON format with custom filename')

argParser.add_argument('-d', '--database', action='store', dest='DB_PATH',
                       metavar='in.db',
                       type=str,
                       required=True,
                       help='Path to sqlite3 database file')

options = argParser.parse_args()

if options.EXPORT_JSON_NAME:
    options.EXPORT_JSON = True

# ROOT has its own opinions about argument parsing. Don't import it until it's
# too late for it to screw things up.
from ROOT import *

# Get everything styled nicely
gROOT.Macro('$SRT_PUBLIC_CONTEXT/Utilities/rootlogon.C')


#///////////////////////////////////////////////////////////////////////////////
#  This is used for pushing the sqlite3 query results into a dictionary
def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


#///////////////////////////////////////////////////////////////////////////////
#  Make sqlite3 DB connection and create a dictionary from the results
def QueryDB(db):
    conn = sqlite3.connect(db)
    conn.row_factory = dict_factory
    c = conn.cursor()
    return c.execute('SELECT * FROM TimeModule')


#///////////////////////////////////////////////////////////////////////////////
#  Export query results into JSON file, if so desired by the user
def ExportJSON(data):
    json_filename = (options.EXPORT_JSON_NAME if options.EXPORT_JSON_NAME else "out.json")

    # Open file for writing
    file = open(json_filename, 'w')

    # Encode JSON and write to file
    file.write(json.dumps(data, indent = 2, sort_keys = True, default=lambda o: o.__dict__))

    # Close file
    file.close()

    print "JSON file written to out.json"


#///////////////////////////////////////////////////////////////////////////////
def main():
    executeQuery = QueryDB(options.DB_PATH)

    results = []

    # Module name -> list of times
    ts = {}

    for row in executeQuery:
        # Get some stuff
        mod = row["PathModuleId"]
        t = row["Time"]

        if mod not in ts: ts[mod] = []
        ts[mod].append(t)

        # Append each row to a results array (used for outputting JSON)
        results.append(row)

    # Automatically determine a good axis range
    # 20% more than the largest 90% quantile
    tmax = 0
    for mod in ts:
        ts[mod].sort()
        tmax_mod = ts[mod][int(len(ts[mod])*.9)]*1.2
        tmax = tmax_mod if tmax_mod > tmax else tmax

    # Create and fill the histograms
    hs = {}
    for mod in ts:
        hs[mod] = TH1F('', ';Time (s);Events', 100, 0, tmax)

        for t in ts[mod]:
            hs[mod].Fill(t)

    # TODO bigger/better set of automatic colours
    cols = [kRed, kGreen+2, kBlue, kMagenta, kOrange-1, kMagenta+3, kGray+2]
    colIdx = 0

    leg = TLegend(.5, .5, .85, .85)
    leg.SetFillStyle(0)

    once = True
    for key in hs:
        h = hs[key]
        h.SetLineColor(cols[colIdx])
        colIdx = (colIdx+1) % len(cols)
        h.Draw('hist' if once else 'hist same')
        once = False
        label = key.split(':')[-1] # only need the last part of the name
        leg.AddEntry(h, label, 'l')

    leg.Draw()


    if options.OUTPUT:
        print 'Saving output to', options.OUTPUT
        gPad.Print(options.OUTPUT)

    if options.EXPORT_JSON:
        ExportJSON(results)

    if not options.QUIT:
        # Just want the console to hang around so the user can look at the
        # plots without them disappearing. Ctrl-D or 'exit()' to quit.
        print 'Ctrl-D to quit'
        code.interact(local = locals(), banner='')


#///////////////////////////////////////////////////////////////////////////////
if __name__ == "__main__":
    main()
